# Что такое состояние компонента?

**Состояние (state)** компонента — это любые данные, которые хранятся в компоненте и представляют пользовательский интерфейс. Это может быть текущее значение текстового поля, набор значений различных полей в компоненте формы, активное изображение в галерее, а также любые другие данные, которые меняются, когда пользователь взаимодействует с интерфейсом. Далее мы попробуем детально разобраться в том, как устроено состояние компонента в React.

## Компоненты

В современном React **компонент** — это обычная JavaScript-функция, название которой всегда начинается с заглавной буквы. Эта функция может принимать в качестве аргумента объект `props`, содержащий любые данные, переданные ей от родительского компонента. Такая функция-компонент обычно возвращает дерево дочерних HTML-элементов, React-компонентов или их комбинацию. Возвращаемое дерево описывается специальным синтаксисом **JSX (JavaScript XML)**, очень похожим на HTML. Дочерние элементы и компоненты могут использовать данные в атрибутах, определенные следующими способами:

- данные, заданные “на месте” в самом атрибуте;
- данные, описанные за пределами компонента;
- данные, присвоенные локальным переменным, объявленным внутри компонента;
- данные, пришедшие в аргументе компонента в виде объекта `props`.

Давайте вспомним, как выглядит типичный компонент в React:

```tsx
const defaultPlaceholder = "Enter text..."

export const TextInput = (props) => {
	const inputClassName = 'text-input';

	return (
		<input
			type="text"
			placeholder={defaultPlaceholder}
			className={inputClassName}
			value={props.value}
			onChange={props.onChange}
		/>
	);
};
```

Компонент `TextInput` называется **контролируемым**, так как его поведение полностью контролируется значениями, которые ему передал родительский компонент через объект `props`. Мы не могли бы использовать его независимо от родительского компонента, который каким-либо образом контролирует значение `value` и предоставляет функцию обратного вызова (колбэк) `onChange` для изменения значения `value`. Такой механизм контроля поведения может быть реализован по-разному, но чаще всего для этого используется **состояние компонента**. Обычно в реальных проектах контроль над значениями полей пользовательского ввода осуществляется в компоненте формы, поэтому давайте посмотрим на пример такого компонента, который контролирует один компонент `TextInput`. При этом мы попробуем реализовать его состояние стандартными средствами JavaScript — через внутреннюю переменную и колбэк, который будет изменять данную переменную при вызове этого колбэка в контролируемом компоненте `TextInput`.

```tsx
import { TextInput } from './TextInput';

export const Form = () => {
	let inputValue = '';

	const onChangeInputValue = (event) => {
		inputValue = inputValue + event.target.value;

		console.log(inputValue);
	}

	return (
		<>
			<TextInput value={inputValue} onChange={onChangeInputValue} />

			<div>Current value: {inputValue}</div>
		</>
	);
};
```

С первого взгляда, интерфейс хранения и изменения значения текстового поля реализован корректно: при срабатывании каждого события `onChange` на текстовом поле будет вызван метод-обработчик `onChangeInputValue`, в котором переменная `inputValue`, объявленная внутри компонента `Form`, получит обновлённое значение текстового поля. При взаимодействии с текстовым полем мы увидим, что в консоли браузера выводится то, что мы вводим в это поле, но на внешний вид самих компонентов это не повлияет. Так происходит потому, что наша реализация состояния компонента не связана с так называемым **рендерингом** — встроенным в React механизмом отрисовки в HTML-документе тех изменений, которые произошли в интерфейсе компонентов.

Давайте детально рассмотрим, как устроен процесс рендеринга компонентов, а далее попробуем связать его с процессом изменения их состояния.

### Рендеринг компонентов

При старте React-приложения все компоненты проходят через стадию изначального рендеринга, после которой в HTML-документе отображается дерево компонентов в виде соответствующих им DOM-узлов. Если у компонента есть состояние, то в стадии изначального рендеринга будет использовано его значение по умолчанию. Когда состояние компонента меняется в ответ на пользовательские действия, это вызывает **ререндеринг** (перерисовку) компонента, а также его дочерних компонентов, если явно не указано, что этот ререндеринг их не затрагивает. Это значит, что React снова вызовет нужные функции-компоненты, создаст так называемый **снимок (snapshot)** компонента, который будет содержать уникальное для этого снимка состояние, также будет существовать и использоваться только до следующего рендера, и только после этого в HTML-документе отобразятся минимальные и необходимые изменения в соответствующих компонентам DOM-узлах, зависящие от нового состояния.

В примере с формой, приведенном выше, не происходит обновлений DOM в ответ на изменения локальной переменной именно потому, что React не знает, что компонент был изменен. Для этого мы должны были бы вызывать новый рендер компонента, и в прошлых версиях React, в которых для компонентов с состоянием использовались классы, мы могли для такой задачи использовать метод `Component.forceUpdate()`. В современном функциональном React такой возможности нет, да и раньше этот метод использовался только для работы с полноценными внешними источниками данных, типа сторонних библиотек или браузерных API. Но все же представим, что такая возможность запускать ререндеринг непосредственно из компонента у нас есть — тогда при каждом новом рендере наш компонент будет заново вызван и в снимке этого компонента снова окажется дефолтное значение локальной переменной.

Мы пришли к тому, что обновления состояния в компоненте будут работать правильно только при соблюдении двух следующих условий:

1. Обновление состояния будет вызывать ререндеринг компонента;
2. React будет сохранять состояние между рендерами компонента и сообщать его новое значение компоненту после каждого ререндеринга.

Получается, что для работы с состоянием нам необходим механизм, который позволяет обновлять интерфейс в ответ на пользовательские действия, взаимодействуя с механизмом рендеринга. К счастью, React предоставляет такой механизм через хуки. **Хуки** — это специальные функции, вызываемые в компоненте, которые доступны только, пока React рендерит компонент. В первую очередь нас интересуют хуки `useState` и `useReducer`, так как именно они созданы для работы с состоянием компонента.

Для начала давайте рассмотрим базовый хук `useState`.
